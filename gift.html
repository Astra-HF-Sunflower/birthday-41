<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœ£è¯ç¤¼ç‰©å †å å¤§å¸ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #0f172a;
        }
        h1, h2, .christmas-font {
            font-family: 'Mountains of Christmas', cursive;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }
        .btn-shine {
            position: relative;
            overflow: hidden;
        }
        .btn-shine::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: rotate(45deg);
            transition: all 0.5s;
            animation: shine 3s infinite;
        }
        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }
        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
    </style>
</head>
<body class="h-screen w-screen relative select-none text-white bg-slate-900">
    <!-- Game Canvas -->
    <canvas id="gameCanvas" class="block w-full h-full cursor-pointer"></canvas>
    <!-- UI Layer -->
    <div id="uiLayer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-6">
        <!-- Header -->
        <div class="flex justify-between items-start w-full max-w-lg mx-auto">
            <div class="glass-panel rounded-2xl px-5 py-2 flex flex-col items-center animate-float">
                <span class="text-xs text-gray-300 font-bold uppercase tracking-wider">å½“å‰å±‚æ•°</span>
                <span id="scoreDisplay" class="text-4xl text-yellow-300 font-bold christmas-font" style="text-shadow: 0 0 10px rgba(234, 179, 8, 0.5)">0</span>
            </div>
            <div class="glass-panel rounded-2xl px-5 py-2 flex flex-col items-center">
                <span class="text-xs text-gray-300 font-bold uppercase tracking-wider">æœ€é«˜çºªå½•</span>
                <span id="bestScoreDisplay" class="text-2xl text-white font-bold christmas-font">0</span>
            </div>
        </div>
        
        <!-- Combo Text (Hidden by default) -->
        <div id="comboContainer" class="absolute top-1/3 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none opacity-0 transition-opacity duration-300">
            <div id="comboText" class="text-5xl font-bold text-yellow-300 christmas-font drop-shadow-lg scale-150">Perfect!</div>
        </div>
    </div>
    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center bg-black/70 z-50 backdrop-blur-sm transition-opacity duration-500">
        <div class="glass-panel p-10 rounded-3xl text-center max-w-md w-[90%] border-t-4 border-red-500 shadow-2xl transform hover:scale-[1.02] transition-transform duration-300 relative overflow-hidden">
            <!-- Decorative Elements -->
            <div class="absolute -top-10 -left-10 w-32 h-32 bg-red-500 rounded-full blur-3xl opacity-20"></div>
            <div class="absolute -bottom-10 -right-10 w-32 h-32 bg-green-500 rounded-full blur-3xl opacity-20"></div>
            <h1 class="text-6xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-red-600 drop-shadow-sm py-2">ç¤¼ç‰©å †å †ä¹</h1>
            <p class="text-xl mb-8 text-gray-200 christmas-font">åœ¨è¿™ä¸ªåœ£è¯èŠ‚ï¼Œä½ èƒ½å †å¤šé«˜ï¼ŸğŸ„</p>
            
            <button id="startBtn" class="btn-shine bg-gradient-to-r from-red-600 to-red-700 w-full py-4 rounded-xl text-2xl font-bold shadow-lg shadow-red-900/50 hover:shadow-red-500/50 transition-all active:scale-95 text-white border border-white/20 cursor-pointer pointer-events-auto christmas-font">
                å¼€å§‹æŒ‘æˆ˜
            </button>
            <p class="mt-6 text-sm text-gray-400 font-medium">ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®æ”¾ç½®ç¤¼ç‰©ç›’</p>
        </div>
    </div>
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center bg-black/80 z-50 backdrop-blur-md">
        <div class="glass-panel p-10 rounded-3xl text-center max-w-md w-[90%] border-t-4 border-green-500 shadow-2xl animate-float relative">
             <!-- Decorative Elements -->
             <div class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-6xl drop-shadow-lg">ğŸ</div>
            <h2 class="text-5xl font-bold mb-6 text-white christmas-font mt-4">å™¢ï¼Œå€’äº†!</h2>
            
            <div class="flex justify-center gap-8 mb-8">
                <div class="flex flex-col">
                    <span class="text-sm text-gray-400 uppercase">æœ€ç»ˆå±‚æ•°</span>
                    <span id="finalScore" class="text-5xl font-bold text-yellow-300 drop-shadow-lg christmas-font">0</span>
                </div>
            </div>
            
            <button id="restartBtn" class="btn-shine bg-gradient-to-r from-green-600 to-green-700 w-full py-4 rounded-xl text-2xl font-bold shadow-lg shadow-green-900/50 hover:shadow-green-500/50 transition-all active:scale-95 text-white border border-white/20 cursor-pointer pointer-events-auto christmas-font">
                å†è¯•ä¸€æ¬¡
            </button>
        </div>
    </div>
    <script>
        // --- æ¸¸æˆé…ç½® ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // è°ƒè‰²æ¿
        const PALETTE = {
            red: { main: '#dc2626', light: '#ef4444', dark: '#991b1b' },
            green: { main: '#16a34a', light: '#22c55e', dark: '#14532d' },
            gold: { main: '#ca8a04', light: '#eab308', dark: '#854d0e' },
            blue: { main: '#2563eb', light: '#3b82f6', dark: '#1e3a8a' },
            purple: { main: '#9333ea', light: '#a855f7', dark: '#581c87' }
        };
        const COLORS = Object.values(PALETTE);
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, ANIMATING_RESET
        let score = 0;
        let bestScore = localStorage.getItem('xmasstack_best') || 0;
        document.getElementById('bestScoreDisplay').innerText = bestScore;
        // æ¸¸æˆé€»è¾‘å˜é‡
        let stack = [];
        let currentBlock = null;
        let debris = [];
        let particles = [];
        let backgroundStars = [];
        let cameraY = 0;
        let targetCameraY = 0;
        
        let blockHeight = 40; // è¿™é‡Œçš„heightæ˜¯æŒ‡è§†è§‰ä¸Šçš„åšåº¦
        let initialBlockSize = 200; // è¿™é‡Œçš„sizeæ˜¯æŒ‡å®½åº¦/æ·±åº¦
        let moveSpeed = 3;
        let moveDirection = 1; // 1 or -1
        let comboCount = 0;
        // --- åˆå§‹åŒ–ä¸å“åº”å¼ ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initBackground();
        }
        window.addEventListener('resize', resize);
        // --- è§†è§‰ç»˜åˆ¶è¾…åŠ©å‡½æ•° ---
        function drawCube(x, y, width, height, colorObj, alpha = 1) {
            // ä¼ª3Dæ•ˆæœï¼šç®€å•çš„ç­‰è½´æµ‹æŠ•å½±æ„Ÿè§‰
            // é¡¶é¢ä¸éœ€è¦ç”»ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯ä»æ­£ä¾§é¢çœ‹ï¼Œä½†æ˜¯ä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬åšä¸€ä¸ªé€è§†
            // å®é™…ä¸Šï¼Œè¿™æ›´åƒæ˜¯ä¸€ä¸ªå¸¦æœ‰åšåº¦çš„2DçŸ©å½¢ï¼Œç¨å¾®åŠ ä¸€ç‚¹é¡¶éƒ¨çš„é€è§†
            
            const depth = height * 0.6; // è§†è§‰ä¸Šçš„æ·±åº¦/é«˜åº¦æ¯”ä¾‹
            const perspectiveY = y + cameraY;
            ctx.globalAlpha = alpha;
            // 1. ä¾§é¢ (ä¸»ä½“)
            ctx.fillStyle = colorObj.main;
            ctx.fillRect(x, perspectiveY, width, height);
            
            // ä¾§é¢å…‰æ³½/é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(x, perspectiveY, width/2, height);
            // 2. é¡¶é¢ (é€è§†æ„Ÿ)
            ctx.fillStyle = colorObj.light;
            ctx.beginPath();
            ctx.moveTo(x, perspectiveY);
            ctx.lineTo(x + width, perspectiveY);
            ctx.lineTo(x + width + depth*0.5, perspectiveY - depth);
            ctx.lineTo(x + depth*0.5, perspectiveY - depth);
            ctx.closePath();
            ctx.fill();
            // 3. å³ä¾§é¢ (é€è§†æ„Ÿ)
            ctx.fillStyle = colorObj.dark;
            ctx.beginPath();
            ctx.moveTo(x + width, perspectiveY);
            ctx.lineTo(x + width + depth*0.5, perspectiveY - depth);
            ctx.lineTo(x + width + depth*0.5, perspectiveY - depth + height);
            ctx.lineTo(x + width, perspectiveY + height);
            ctx.closePath();
            ctx.fill();
            
            // è£…é¥°ï¼šä¸å¸¦
            ctx.fillStyle = '#fbbf24'; // é‡‘è‰²ä¸å¸¦
            // å‚ç›´ä¸å¸¦
            ctx.fillRect(x + width/2 - 5, perspectiveY, 10, height); // æ­£é¢
            
            // é¡¶é¢ä¸å¸¦
            ctx.beginPath();
            ctx.moveTo(x + width/2 - 5, perspectiveY);
            ctx.lineTo(x + width/2 + 5, perspectiveY);
            ctx.lineTo(x + width/2 + 5 + depth*0.5, perspectiveY - depth);
            ctx.lineTo(x + width/2 - 5 + depth*0.5, perspectiveY - depth);
            ctx.fill();
            
            // å³é¢ä¸å¸¦
            // æš‚æ—¶ç•¥è¿‡å³é¢ä¸å¸¦ï¼Œä¿æŒç®€æ´
            
            // è£…é¥°ï¼šè´è¶ç»“ (ç®€å•çš„)
            if (alpha > 0.8) { // åªåœ¨ä¸é€æ˜æ—¶ç”»ç»†èŠ‚
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                const centerX = x + width/2 + depth*0.25;
                const centerY = perspectiveY - depth/2;
                ctx.arc(centerX, centerY - 5, 8, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        // --- èƒŒæ™¯ç³»ç»Ÿ ---
        function initBackground() {
            backgroundStars = [];
            for(let i=0; i<100; i++) {
                backgroundStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    alpha: Math.random(),
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }
        function drawBackground() {
            // æ¸å˜èƒŒæ™¯ï¼šéšç€é«˜åº¦å˜æ·±
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#020617'); // æ·±é‚ƒå¤œç©º
            gradient.addColorStop(1, '#1e293b'); // åœ°é¢é™„è¿‘
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // æ˜Ÿæ˜Ÿ/é›ªèŠ±
            ctx.fillStyle = '#fff';
            backgroundStars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) star.y = 0;
                
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            // åœ°é¢è£…é¥°
            if (cameraY > -canvas.height) {
                const groundY = canvas.height / 1.2 + cameraY;
                
                // é›ªåœ°
                ctx.fillStyle = '#f1f5f9';
                ctx.beginPath();
                ctx.ellipse(canvas.width/2, groundY + 100, canvas.width, 150, 0, 0, Math.PI*2);
                ctx.fill();
                // ç®€å•çš„æ ‘
                drawTree(canvas.width * 0.15, groundY);
                drawTree(canvas.width * 0.85, groundY);
                drawTree(canvas.width * 0.25, groundY + 20);
            }
        }
        function drawTree(x, y) {
            ctx.fillStyle = '#14532d';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 20, y + 60);
            ctx.lineTo(x + 20, y + 60);
            ctx.fill();
            
            // æ ‘å¹²
            ctx.fillStyle = '#78350f';
            ctx.fillRect(x-4, y+60, 8, 15);
        }
        // --- æ ¸å¿ƒæ¸¸æˆé€»è¾‘ ---
        
        function startGame() {
            if (gameState === 'PLAYING') return;
            
            gameState = 'PLAYING';
            score = 0;
            comboCount = 0;
            stack = [];
            debris = [];
            particles = [];
            cameraY = 0;
            targetCameraY = 0;
            moveSpeed = 4;
            blockHeight = 50; // æ¯ä¸€å±‚çš„é«˜åº¦
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('scoreDisplay').innerText = score;
            // åˆå§‹åŸºåº§
            const baseWidth = Math.min(300, canvas.width * 0.6);
            const baseBlock = {
                x: (canvas.width - baseWidth) / 2,
                y: canvas.height / 1.2,
                width: baseWidth,
                height: blockHeight,
                color: PALETTE.red
            };
            stack.push(baseBlock);
            spawnNextBlock();
        }
        function spawnNextBlock() {
            const prevBlock = stack[stack.length - 1];
            // éšæœºé¢œè‰²ä½†ä¸èƒ½å’Œä¸Šä¸€ä¸ªä¸€æ ·
            let nextColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            while(nextColor === prevBlock.color && COLORS.length > 1) {
                nextColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            }
            // æ–°æ–¹å—çš„Yåæ ‡åœ¨ä¸Šä¸€å±‚ä¹‹ä¸Š
            // æ³¨æ„ï¼šå› ä¸ºæˆ‘ä»¬æ˜¯ Canvas åæ ‡ç³»ï¼ŒYè¶Šå°è¶Šé«˜
            const newY = prevBlock.y - blockHeight;
            // ç¡®å®šç”Ÿæˆä½ç½®å’Œæ–¹å‘
            // å¦‚æœæ˜¯å¶æ•°å±‚ï¼Œä»å·¦è¾¹å‡ºæ¥ï¼›å¥‡æ•°å±‚ä»å³è¾¹å‡ºæ¥
            const isLeft = stack.length % 2 === 0;
            const startX = isLeft ? -prevBlock.width : canvas.width;
            moveDirection = isLeft ? 1 : -1;
            currentBlock = {
                x: startX,
                y: newY,
                width: prevBlock.width,
                height: blockHeight,
                color: nextColor,
                speed: moveSpeed + (score * 0.1) // éš¾åº¦éšåˆ†æ•°å¢åŠ 
            };
            
            // ç›¸æœºç›®æ ‡ä½ç½®æ›´æ–°ï¼šä¿æŒå½“å‰æ–¹å—åœ¨å±å¹•ä¸­ä¸‹éƒ¨
            // ç†æƒ³ä½ç½®ï¼šcanvas.height * 0.6
            // å½“å‰å †å é«˜åº¦ï¼šcanvas.height / 1.2 - score * blockHeight
            // æˆ‘ä»¬éœ€è¦ç§»åŠ¨ cameraY ä½¿å¾— currentBlock.y + cameraY â‰ˆ canvas.height * 0.6
            const desiredScreenY = canvas.height * 0.6;
            targetCameraY = desiredScreenY - newY;
        }
        function placeBlock() {
            if (gameState !== 'PLAYING' || !currentBlock) return;
            const prevBlock = stack[stack.length - 1];
            
            // è®¡ç®—é‡å è·ç¦»
            const dist = currentBlock.x - prevBlock.x;
            const absDist = Math.abs(dist);
            
            // å®¹å·®èŒƒå›´
            const tolerance = 5;
            // å®Œç¾é‡åˆ
            if (absDist <= tolerance) {
                currentBlock.x = prevBlock.x; // è‡ªåŠ¨å¯¹é½
                comboCount++;
                showCombo();
                createParticles(currentBlock.x + currentBlock.width/2, currentBlock.y, '#fbbf24', 20); // é‡‘è‰²ç²’å­
                
                // Comboå¥–åŠ±ï¼šå¦‚æœä¹‹å‰è¢«åˆ‡å°äº†ï¼Œå¯ä»¥ç¨å¾®æ¢å¤ä¸€ç‚¹å®½åº¦ï¼ˆå¯é€‰ï¼‰
                if (comboCount > 3 && currentBlock.width < initialBlockSize) {
                    currentBlock.width = Math.min(currentBlock.width + 10, initialBlockSize);
                    currentBlock.x -= 5; // ä¿æŒä¸­å¿ƒ
                }
            } else if (absDist >= currentBlock.width) {
                // å®Œå…¨æ²¡æ¥ä½ï¼Œæ¸¸æˆç»“æŸ
                gameOver();
                return;
            } else {
                // åˆ‡å‰²é€»è¾‘
                comboCount = 0;
                
                // ä¿ç•™éƒ¨åˆ†çš„å®½åº¦
                const newWidth = currentBlock.width - absDist;
                
                // æ‰è½éƒ¨åˆ†çš„å®½åº¦å’Œä½ç½®
                const fallingWidth = absDist;
                const fallingX = dist > 0 
                    ? currentBlock.x + newWidth // å³è¾¹æ‰è½
                    : currentBlock.x;       // å·¦è¾¹æ‰è½
                
                // æ›´æ–°å½“å‰å—ï¼ˆä¿ç•™éƒ¨åˆ†ï¼‰
                currentBlock.width = newWidth;
                currentBlock.x = dist > 0 ? currentBlock.x : prevBlock.x;
                // åˆ›å»ºæ‰è½å—ç‰¹æ•ˆ
                debris.push({
                    x: fallingX,
                    y: currentBlock.y,
                    width: fallingWidth,
                    height: currentBlock.height,
                    color: currentBlock.color,
                    vy: 0,
                    vx: dist > 0 ? 2 : -2,
                    rot: 0,
                    vRot: (Math.random() - 0.5) * 0.2
                });
                
                createParticles(fallingX + fallingWidth/2, currentBlock.y + blockHeight, '#fff', 10);
            }
            stack.push(currentBlock);
            score++;
            document.getElementById('scoreDisplay').innerText = score;
            
            spawnNextBlock();
        }
        function gameOver() {
            gameState = 'GAMEOVER';
            
            // å¦‚æœæœ‰æ­£åœ¨ç§»åŠ¨çš„å—ï¼Œè®©å®ƒæ‰ä¸‹å»
            if (currentBlock) {
                debris.push({
                    x: currentBlock.x,
                    y: currentBlock.y,
                    width: currentBlock.width,
                    height: currentBlock.height,
                    color: currentBlock.color,
                    vy: 2,
                    vx: moveDirection * 2,
                    rot: 0,
                    vRot: (Math.random() - 0.5) * 0.2
                });
                currentBlock = null;
            }
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('xmasstack_best', bestScore);
            }
            
            setTimeout(() => {
                document.getElementById('finalScore').innerText = score;
                document.getElementById('bestScoreDisplay').innerText = bestScore;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }, 800);
        }
        // --- ç‰¹æ•ˆç³»ç»Ÿ ---
        function showCombo() {
            const el = document.getElementById('comboContainer');
            const text = document.getElementById('comboText');
            
            el.style.opacity = '1';
            el.style.top = (canvas.height/2 - 100) + 'px';
            text.innerText = ['Nice!', 'Great!', 'Perfect!', 'Amazing!'][Math.min(comboCount-1, 3)] || 'Perfect!';
            
            // Trigger reflow for animation
            text.style.transform = 'scale(1.5)';
            setTimeout(() => text.style.transform = 'scale(1)', 50);
            setTimeout(() => {
                el.style.opacity = '0';
            }, 800);
        }
        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        // --- ä¸»å¾ªç¯ ---
        function update() {
            // å¹³æ»‘ç§»åŠ¨ç›¸æœº
            cameraY += (targetCameraY - cameraY) * 0.1;
            if (gameState === 'PLAYING' && currentBlock) {
                currentBlock.x += currentBlock.speed * moveDirection;
                // ç®€å•çš„åå¼¹é€»è¾‘ï¼ˆå¦‚æœè¿˜æ²¡ç‚¹å‡»ï¼‰
                // ä¸ºäº†æ¸¸æˆæ€§ï¼Œæˆ‘ä»¬ä¸ä»…åå¼¹ï¼Œè€Œä¸”å¦‚æœè¶…å‡ºå±å¹•å¤ªè¿œåˆ¤è´Ÿï¼Œæˆ–è€…å°±è¿™æ ·æ¥å›
                // ç»å…¸ Stack æ¸¸æˆæ˜¯æ¥å›åå¼¹çš„
                if (currentBlock.x < -100 || currentBlock.x > canvas.width + 100) {
                     moveDirection *= -1;
                }
                // å®é™…ä¸Š Stack æ¸¸æˆæ˜¯ç¢°åˆ°å±å¹•è¾¹ç¼˜åå¼¹
                const rightEdge = canvas.width - currentBlock.width;
                if (currentBlock.x > rightEdge + 50) moveDirection = -1;
                if (currentBlock.x < -50) moveDirection = 1;
            }
            // æ›´æ–°ç¢ç‰‡
            for (let i = debris.length - 1; i >= 0; i--) {
                const d = debris[i];
                d.x += d.vx;
                d.y += d.vy;
                d.vy += 0.8; // Gravity
                d.rot += d.vRot;
                if (d.y > canvas.height + 200 - cameraY) { // è¶…å‡ºå¯è§†èŒƒå›´ï¼ˆè€ƒè™‘ç›¸æœºï¼‰
                    debris.splice(i, 1);
                }
            }
            // æ›´æ–°ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            // ç»˜åˆ¶å †å çš„æ–¹å—
            for (let block of stack) {
                // åªæœ‰åœ¨å±å¹•å†…çš„æ‰ç»˜åˆ¶
                if (block.y + cameraY < canvas.height && block.y + cameraY > -100) {
                    drawCube(block.x, block.y, block.width, block.height, block.color);
                }
            }
            // ç»˜åˆ¶å½“å‰ç§»åŠ¨çš„æ–¹å—
            if (currentBlock) {
                drawCube(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.height, currentBlock.color);
            }
            // ç»˜åˆ¶ç¢ç‰‡
            for (let d of debris) {
                ctx.save();
                ctx.translate(d.x + d.width/2, d.y + cameraY + d.height/2);
                ctx.rotate(d.rot);
                // ç®€å•çš„ç»˜åˆ¶ç¢ç‰‡ï¼Œä¸éœ€è¦å¤ªå¤æ‚çš„é€è§†
                ctx.fillStyle = d.color.main;
                ctx.fillRect(-d.width/2, -d.height/2, d.width, d.height);
                ctx.restore();
            }
            // ç»˜åˆ¶ç²’å­
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y + cameraY, p.size, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }
        // --- è¾“å…¥å¤„ç† ---
        function handleInput(e) {
            e.preventDefault(); // é˜²æ­¢åŒå‡»ç¼©æ”¾ç­‰
            if (gameState === 'MENU' || gameState === 'GAMEOVER') return;
            placeBlock();
        }
        // ç»‘å®šäº‹ä»¶
        document.getElementById('startBtn').addEventListener('click', (e) => {
            e.stopPropagation(); // é˜²æ­¢å†’æ³¡è§¦å‘canvasç‚¹å‡»
            startGame();
        });
        
        document.getElementById('restartBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            startGame();
        });
        // æ•´ä¸ªå±å¹•ç‚¹å‡»éƒ½æœ‰æ•ˆ
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, {passive: false});
        
        // é”®ç›˜ç©ºæ ¼é”®ä¹Ÿå¯ä»¥ç©
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (gameState === 'PLAYING') placeBlock();
                else if (gameState !== 'PLAYING' && !document.getElementById('startScreen').classList.contains('hidden')) startGame(); 
                else if (gameState === 'GAMEOVER') startGame();
            }
        });
        // å¯åŠ¨
        initBackground();
        resize();
        loop();
    </script>
</body>
</html>
